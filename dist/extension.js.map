{"version":3,"sources":["../webpack/bootstrap",".././src/extension.ts","../external \"util\"","../external \"vscode\"",".././src/package.ts",".././src/rTerminal.ts",".././node_modules/fs-extra/lib/index.js",".././node_modules/fs-extra/lib/fs/index.js",".././node_modules/universalify/index.js",".././node_modules/graceful-fs/graceful-fs.js","../external \"fs\"",".././node_modules/graceful-fs/polyfills.js","../external \"constants\"",".././node_modules/graceful-fs/legacy-streams.js","../external \"stream\"",".././node_modules/graceful-fs/clone.js","../external \"assert\"",".././node_modules/fs-extra/lib/copy-sync/index.js",".././node_modules/fs-extra/lib/copy-sync/copy-sync.js","../external \"path\"",".././node_modules/fs-extra/lib/mkdirs/index.js",".././node_modules/fs-extra/lib/mkdirs/mkdirs.js",".././node_modules/fs-extra/lib/mkdirs/win32.js",".././node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js",".././node_modules/fs-extra/lib/util/utimes.js","../external \"os\"",".././node_modules/fs-extra/lib/util/buffer.js",".././node_modules/fs-extra/lib/copy/index.js",".././node_modules/fs-extra/lib/copy/copy.js",".././node_modules/fs-extra/lib/path-exists/index.js",".././node_modules/fs-extra/lib/empty/index.js",".././node_modules/fs-extra/lib/remove/index.js",".././node_modules/fs-extra/lib/remove/rimraf.js",".././node_modules/fs-extra/lib/ensure/index.js",".././node_modules/fs-extra/lib/ensure/file.js",".././node_modules/fs-extra/lib/ensure/link.js",".././node_modules/fs-extra/lib/ensure/symlink.js",".././node_modules/fs-extra/lib/ensure/symlink-paths.js",".././node_modules/fs-extra/lib/ensure/symlink-type.js",".././node_modules/fs-extra/lib/json/index.js",".././node_modules/fs-extra/lib/json/jsonfile.js",".././node_modules/jsonfile/index.js",".././node_modules/fs-extra/lib/json/output-json.js",".././node_modules/fs-extra/lib/json/output-json-sync.js",".././node_modules/fs-extra/lib/move-sync/index.js",".././node_modules/fs-extra/lib/move/index.js",".././node_modules/fs-extra/lib/output/index.js",".././src/util.ts",".././src/preview.ts",".././src/selection.ts",".././src/lineCache.ts",".././node_modules/winattr/lib/index.js",".././node_modules/winattr/lib/checkWindows.js",".././node_modules/winattr/lib/whichLib.js",".././node_modules/winattr/lib/binding/index.js",".././node_modules/fswin/index.js",".././node_modules/fswin sync ^.*\\/fswin\\.node$",".././node_modules/winattr/lib/binding/convertAttrs.js",".././node_modules/winattr/lib/shell/index.js","../external \"child_process\"",".././src/rGitignore.ts"],"names":[],"mappings":"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AACA,eAAe,oBAAoB;AACnC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,KAAK;AACL,GAAG;AACH;;;;;;;;ACvGY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG,WAAW,iBAAiB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,WAAW,iBAAiB;AAC/B;;;;;;;ACxBA,SAAS,mBAAO,CAAC,CAAI;AACrB,gBAAgB,mBAAO,CAAC,EAAgB;AACxC,aAAa,mBAAO,CAAC,EAAqB;AAC1C,YAAY,mBAAO,CAAC,EAAY;;AAEhC;;AAEA,WAAW,mBAAO,CAAC,CAAM;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,mBAAO,CAAC,EAAQ;AACpB,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;AAEF,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtRA,+B;;;;;;ACAA,gBAAgB,mBAAO,CAAC,EAAW;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,yCAAyC;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACxUA,sC;;;;;;ACAA,aAAa,mBAAO,CAAC,EAAQ;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrHA,mC;;;;;;;ACAY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;AClBA,mC;;;;;;;ACAY;;AAEZ;AACA,YAAY,mBAAO,CAAC,EAAa;AACjC;;;;;;;;ACJY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,mBAAmB,mBAAO,CAAC,EAAW;AACtC,mBAAmB,mBAAO,CAAC,EAAmB;;AAE9C;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kGAAkG;AAClG;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,wBAAwB,KAAK;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,EAAgB;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,KAAK,oBAAoB,IAAI;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,kCAAkC,aAAa;AACjG;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,UAAU,YAAY;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uCAAuC;AACvC;AACA;AACA,UAAU;AACV;;AAEA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACA;AACA;AACA,oCAAoC,IAAI,kCAAkC,KAAK;AAC/E;AACA;AACA;;AAEA;;;;;;;AChMA,iC;;;;;;;ACAY;AACZ,UAAU,mBAAO,CAAC,CAAc;AAChC,iBAAiB,mBAAO,CAAC,EAAU;AACnC,mBAAmB,mBAAO,CAAC,EAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,yBAAyB,mBAAO,CAAC,EAAS;;AAE1C;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;AC9DY;;AAEZ,aAAa,mBAAO,CAAC,EAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACxBY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,yBAAyB,mBAAO,CAAC,EAAS;;AAE1C;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACrDY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,WAAW,mBAAO,CAAC,EAAI;AACvB,aAAa,mBAAO,CAAC,EAAM;;AAE3B,YAAY,IAAI;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9EA,+B;;;;;;;ACAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;ACXY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC;AACA,UAAU,mBAAO,CAAC,EAAQ;AAC1B;;;;;;;;ACLY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,eAAe,mBAAO,CAAC,EAAW;AAClC,mBAAmB,mBAAO,CAAC,EAAgB;AAC3C,eAAe,mBAAO,CAAC,EAAgB;;AAEvC;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kGAAkG;AAClG;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,4BAA4B,KAAK;AACjC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,2DAA2D,KAAK,oBAAoB,IAAI;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY,kCAAkC,aAAa;AACzG;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,aAAa,UAAU,YAAY;AACtF;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B;AAChF;AACA;AACA,uBAAuB,kBAAkB;AACzC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,0CAA0C,IAAI,kCAAkC,KAAK;AACrF;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;ACrPY;AACZ,UAAU,mBAAO,CAAC,CAAc;AAChC,WAAW,mBAAO,CAAC,CAAO;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACXY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,WAAW,mBAAO,CAAC,CAAI;AACvB,aAAa,mBAAO,CAAC,EAAM;AAC3B,cAAc,mBAAO,CAAC,EAAW;AACjC,eAAe,mBAAO,CAAC,EAAW;;AAElC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,eAAe,mBAAO,CAAC,EAAU;;AAEjC;AACA;AACA;AACA;;;;;;;;ACRY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,eAAe,mBAAO,CAAC,EAAQ;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzTY;;AAEZ,aAAa,mBAAO,CAAC,EAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,EAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,cAAc,mBAAO,CAAC,EAAW;AACjC,mBAAmB,mBAAO,CAAC,EAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AChDY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,cAAc,mBAAO,CAAC,EAAW;AACjC,mBAAmB,mBAAO,CAAC,EAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC5DY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,gBAAgB,mBAAO,CAAC,EAAW;AACnC;AACA;;AAEA,sBAAsB,mBAAO,CAAC,EAAiB;AAC/C;AACA;;AAEA,qBAAqB,mBAAO,CAAC,EAAgB;AAC7C;AACA;;AAEA,mBAAmB,mBAAO,CAAC,EAAgB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9DY;;AAEZ,aAAa,mBAAO,CAAC,EAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,mBAAmB,mBAAO,CAAC,EAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AClGY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9BY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,iBAAiB,mBAAO,CAAC,EAAY;;AAErC,wBAAwB,mBAAO,CAAC,EAAe;AAC/C,0BAA0B,mBAAO,CAAC,EAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACfY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,iBAAiB,mBAAO,CAAC,EAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA,QAAQ,mBAAO,CAAC,CAAa;AAC7B,CAAC;AACD,QAAQ,mBAAO,CAAC,CAAI;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrIY;;AAEZ,aAAa,mBAAO,CAAC,EAAM;AAC3B,cAAc,mBAAO,CAAC,EAAW;AACjC,mBAAmB,mBAAO,CAAC,EAAgB;AAC3C,iBAAiB,mBAAO,CAAC,EAAY;;AAErC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;;;;;;;AC1BY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,cAAc,mBAAO,CAAC,EAAW;AACjC,iBAAiB,mBAAO,CAAC,EAAY;;AAErC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACjBY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,iBAAiB,mBAAO,CAAC,EAAc;AACvC,mBAAmB,mBAAO,CAAC,EAAW;AACtC,mBAAmB,mBAAO,CAAC,EAAW;AACtC,eAAe,mBAAO,CAAC,EAAgB;;AAEvC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,8DAA8D,IAAI,iBAAiB,KAAK;;AAExF;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACpHY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,aAAa,mBAAO,CAAC,EAAS;AAC9B,eAAe,mBAAO,CAAC,EAAW;AAClC,eAAe,mBAAO,CAAC,EAAW;AAClC,mBAAmB,mBAAO,CAAC,EAAgB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,0CAA0C,IAAI,kCAAkC,KAAK;AACrF;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;;;;;;;ACjF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CAAC,CAAC,CAAC,IAAI,mBAAmB,CAAC,IAAI,CAAC,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC;AAClE,CAAC;;;;;;;;ACjDY;AACb,qBAAqB,mBAAO,CAAC,EAAgB;AAC7C,oBAAoB,mBAAO,CAAC,EAAM;AAClC,iBAAiB,mBAAO,CAAC,EAAY;;;;AAIrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;AAIA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACxEa;AACb;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;ACrCa;AACb,qBAAqB,mBAAO,CAAC,EAAgB;;AAE7C;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,EAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,mBAAO,CAAC,EAAS;;AAEtD;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpGa;AACb,cAAc,mBAAO,CAAC,EAAO;;AAE7B,qBAAqB,mBAAO,CAAC,EAAgB;;;;AAI7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/Ea;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,kBAAkB,wBAAQ,qFAAqF,aAAa,CAAC;AAC7H,CAAC;AACD;AACA,C;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7Ca;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;;;;AAIA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AC5FA,iDAAa;AACb,sBAAsB,mBAAO,CAAC,EAAe;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA,YAAY,8CAA8C;AAC1D,EAAE;AACF;;;;AAIA;AACA;AACA,sDAAsD,gBAAgB;;AAEtE;AACA;AACA;;AAEA;AACA;;;;AAIA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5LA,0C;;;;;;;ACAa;;AAEb,kCAAgC;AAChC,qCAA8B;AAC9B,wCAA4C;AAC5C,MAAM,UAAU,GAAI,IAAI,CAAC,IAAI,CAAC,kBAAS,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;AAChE,oEAAoE;AACpE,MAAM,WAAW,GAAG,CAAC,WAAW;IACZ,eAAe;IACf,QAAQ;IACR,QAAQ;IACR,WAAW;IACX,YAAY;IACZ,cAAc;IACd,kBAAkB;IAClB,iBAAiB;IACjB,aAAa;IACb,WAAW;IACX,SAAS;IACT,WAAW;IACX,WAAW;IACX,YAAY,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAE7C,SAAgB,eAAe;IAC3B,IAAI,CAAC,kBAAS,CAAC,QAAQ,EAAE;QACrB,eAAM,CAAC,kBAAkB,CAAC,4CAA4C,CAAC,CAAC;QACxE,OAAO;KACV;IACD,EAAE,CAAC,SAAS,CAAC,UAAU,EAAE,WAAW,EAAE,CAAC,GAAG,EAAE,EAAE;QAC1C,IAAI;YACA,IAAI,GAAG,EAAE;gBACL,eAAM,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;aACrC;SACJ;QAAC,OAAO,CAAC,EAAE;YACR,eAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;SACtC;IACL,CAAC,CAAC,CAAC;AACP,CAAC;AAdD,0CAcC","file":"extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\n// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport { isNull } from \"util\";\nimport { commands, ExtensionContext, languages, Terminal, window } from \"vscode\";\nimport { buildPkg, documentPkg, installPkg, loadAllPkg, testPkg } from \"./package\";\nimport { previewDataframe, previewEnvironment } from \"./preview\";\nimport { createGitignore } from \"./rGitignore\";\nimport { createRTerm, deleteTerminal, rTerm } from \"./rTerminal\";\nimport { checkForComment, getSelection } from \"./selection\";\nimport { config, delay } from \"./util\";\n\nconst wordPattern = /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\$\\^\\&\\*\\(\\)\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\<\\>\\/\\s]+)/g;\n\n// This method is called when your extension is activated\n// Your extension is activated the very first time the command is executed\nexport function activate(context: ExtensionContext) {\n    // Use the console to output diagnostic information (console.log) and errors (console.error)\n    // This line of code will only be executed once when your extension is activated\n\n    // The command has been defined in the package.json file\n    // Now provide the implementation of the command with  registerCommand\n    // The commandId parameter must match the command field in package.json\n\n    function runSource(echo: boolean)  {\n        const wad = window.activeTextEditor.document;\n        wad.save();\n        let rPath = ToRStringLiteral(wad.fileName, '\"');\n        let encodingParam = config.get(\"source.encoding\") as string;\n        if (encodingParam) {\n            encodingParam = `encoding = \"${encodingParam}\"`;\n            rPath = [rPath, encodingParam].join(\", \");\n        }\n        if (echo) {\n            rPath = [rPath, \"echo = TRUE\"].join(\", \");\n        }\n        if (!rTerm) {\n            const success = createRTerm(true);\n            if (!success) { return; }\n        }\n        rTerm.sendText(`source(${rPath})`);\n        setFocus(rTerm);\n    }\n\n    async function runSelection(rFunctionName: string[]) {\n        const callableTerminal = await chooseTerminal();\n        if (isNull(callableTerminal)) {\n            return;\n        }\n        setFocus(callableTerminal);\n        runSelectionInTerm(callableTerminal, rFunctionName);\n    }\n\n    async function chooseTerminal() {\n        if (window.terminals.length > 0) {\n            const RTermNameOpinions = [\"R\", \"R Interactive\"];\n            if (window.activeTerminal) {\n                const activeTerminalName = window.activeTerminal.name;\n                if (RTermNameOpinions.includes(activeTerminalName)) {\n                    return window.activeTerminal;\n                }\n            } else {\n                // Creating a terminal when there aren't any already\n                // does not seem to set activeTerminal\n                if (window.terminals.length === 1) {\n                    const activeTerminalName = window.terminals[0].name;\n                    if (RTermNameOpinions.includes(activeTerminalName)) {\n                        return window.terminals[0];\n                    }\n                } else {\n                    // tslint:disable-next-line: max-line-length\n                    window.showInformationMessage(\"Error identifying terminal! This shouldn't happen, so please file an issue at https://github.com/Ikuyadeu/vscode-R/issues\");\n                    return null;\n                }\n            }\n        }\n\n        if (!rTerm) {\n            const success = createRTerm(true);\n            await delay(200); // Let RTerm warm up\n            if (!success) {\n                return null;\n            }\n        }\n        return rTerm;\n    }\n\n    function runSelectionInActiveTerm(rFunctionName: string[]) {\n        if (window.terminals.length < 1) {\n            window.showInformationMessage(\"There are no open terminals.\");\n        } else {\n            runSelectionInTerm(window.activeTerminal, rFunctionName);\n            setFocus(window.activeTerminal);\n        }\n    }\n\n    async function runSelectionInTerm(term: Terminal, rFunctionName: string[]) {\n        const selection = getSelection();\n        if (selection.linesDownToMoveCursor > 0) {\n            commands.executeCommand(\"cursorMove\", { to: \"down\", value: selection.linesDownToMoveCursor });\n            commands.executeCommand(\"cursorMove\", { to: \"wrappedLineEnd\" });\n        }\n\n        for (let line of selection.selectedTextArray) {\n            if (checkForComment(line)) {\n                continue;\n            }\n            await delay(8); // Increase delay if RTerm can't handle speed.\n\n            if (rFunctionName && rFunctionName.length) {\n                let rFunctionCall = \"\";\n                for (const feature of rFunctionName) {\n                    rFunctionCall += feature + \"(\";\n                }\n                line = rFunctionCall + line.trim() + \")\".repeat(rFunctionName.length);\n            }\n            term.sendText(line);\n        }\n    }\n\n    function setFocus(term: Terminal) {\n        const focus = config.get(\"source.focus\") as string;\n        term.show(focus !== \"terminal\");\n    }\n\n    languages.setLanguageConfiguration(\"r\", {\n        wordPattern,\n    });\n\n    context.subscriptions.push(\n        commands.registerCommand(\"r.nrow\", () => runSelection([\"nrow\"])),\n        commands.registerCommand(\"r.length\", () => runSelection([\"length\"])),\n        commands.registerCommand(\"r.head\", () => runSelection([\"head\"])),\n        commands.registerCommand(\"r.thead\", () => runSelection([\"t\", \"head\"])),\n        commands.registerCommand(\"r.names\", () => runSelection([\"names\"])),\n        commands.registerCommand(\"r.runSource\", () => runSource(false)),\n        commands.registerCommand(\"r.createRTerm\", createRTerm),\n        commands.registerCommand(\"r.runSourcewithEcho\", () => runSource(true)),\n        commands.registerCommand(\"r.runSelection\", () => runSelection([])),\n        commands.registerCommand(\"r.runSelectionInActiveTerm\", () => runSelectionInActiveTerm([])),\n        commands.registerCommand(\"r.createGitignore\", createGitignore),\n        commands.registerCommand(\"r.previewDataframe\", previewDataframe),\n        commands.registerCommand(\"r.previewEnvironment\", previewEnvironment),\n        commands.registerCommand(\"r.loadAll\", loadAllPkg),\n        commands.registerCommand(\"r.test\", testPkg),\n        commands.registerCommand(\"r.install\", installPkg),\n        commands.registerCommand(\"r.build\", buildPkg),\n        commands.registerCommand(\"r.document\", documentPkg),\n        window.onDidCloseTerminal(deleteTerminal),\n    );\n\n    function ToRStringLiteral(s: string, quote: string) {\n        if (s === null) {\n            return \"NULL\";\n        }\n        return (quote +\n                s.replace(/\\\\/g, \"\\\\\\\\\")\n                .replace(/\"\"\"/g, \"\\\\\" + quote)\n                .replace(/\\\\n/g, \"\\\\n\")\n                .replace(/\\\\r/g, \"\\\\r\")\n                .replace(/\\\\t/g, \"\\\\t\")\n                .replace(/\\\\b/g, \"\\\\b\")\n                .replace(/\\\\a/g, \"\\\\a\")\n                .replace(/\\\\f/g, \"\\\\f\")\n                .replace(/\\\\v/g, \"\\\\v\") +\n                quote);\n    }\n}\n\n// This method is called when your extension is deactivated\n// export function deactivate() {\n\n// }\n","module.exports = require(\"util\");","module.exports = require(\"vscode\");","\"use strict\";\n\nimport { createRTerm, rTerm } from \"./rTerminal\";\n\nexport async function loadAllPkg() {\n    if (!rTerm) {\n        const success = createRTerm(true);\n        if (!success) { return; }\n    }\n\n    const rLoadAllCommand = \"devtools::load_all('.')\";\n    rTerm.sendText(rLoadAllCommand);\n}\n\nexport async function testPkg() {\n    if (!rTerm) {\n        const success = createRTerm(true);\n        if (!success) { return; }\n    }\n\n    const rTestCommand = \"devtools::test()\";\n    rTerm.sendText(rTestCommand);\n}\n\nexport async function installPkg() {\n    if (!rTerm) {\n        const success = createRTerm(true);\n        if (!success) { return; }\n    }\n\n    const rInstallCommand = \"devtools::install()\";\n    rTerm.sendText(rInstallCommand);\n}\n\nexport async function buildPkg() {\n    if (!rTerm) {\n        const success = createRTerm(true);\n        if (!success) { return; }\n    }\n\n    const rBuildCommand = \"devtools::build()\";\n    rTerm.sendText(rBuildCommand);\n}\n\nexport async function documentPkg() {\n    if (!rTerm) {\n        const success = createRTerm(true);\n        if (!success) { return; }\n    }\n\n    const rDocumentCommand = \"devtools::document()\";\n    rTerm.sendText(rDocumentCommand);\n}\n","\"use strict\";\n\nimport fs = require(\"fs-extra\");\nimport { Terminal, window } from \"vscode\";\nimport { config, getRpath } from \"./util\";\nexport let rTerm: Terminal;\n\nexport function createRTerm(preserveshow?: boolean): boolean {\n        const termName = \"R Interactive\";\n        const termPath = getRpath();\n        if (!termPath) {\n            return;\n        }\n        const termOpt =  config.get(\"rterm.option\") as string[];\n        fs.pathExists(termPath, (err, exists) => {\n            if (exists) {\n                rTerm = window.createTerminal(termName, termPath, termOpt);\n                rTerm.show(preserveshow);\n                return true;\n            } else {\n                window.showErrorMessage(\"Cannot find R client.  Please check R path in preferences and reload.\");\n                return false;\n            }\n        });\n    }\n\nexport function deleteTerminal(term: Terminal) {\n    if (term === rTerm) {\n        rTerm = null;\n    }\n}\n","'use strict'\n\nmodule.exports = Object.assign(\n  {},\n  // Export promiseified graceful-fs:\n  require('./fs'),\n  // Export extra methods:\n  require('./copy-sync'),\n  require('./copy'),\n  require('./empty'),\n  require('./ensure'),\n  require('./json'),\n  require('./mkdirs'),\n  require('./move-sync'),\n  require('./move'),\n  require('./output'),\n  require('./path-exists'),\n  require('./remove')\n)\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = require('fs')\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, 'promises', {\n    get () { return fs.promises }\n  })\n}\n","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchown',\n  'lchmod',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'readFile',\n  'readdir',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.copyFile was added in Node.js v8.5.0\n  // fs.mkdtemp was added in Node.js v5.10.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read() & fs.write need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else fn.apply(this, arguments).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar queue = []\n\nvar util = require('util')\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    require('assert').equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\n// Only patch fs once, otherwise we'll run into a memory leak if\n// graceful-fs is loaded multiple times, such as in test environments that\n// reset the loaded modules between tests.\n// We look for the string `graceful-fs` from the comment above. This\n// way we are not adding any extra properties and it will detect if older\n// versions of graceful-fs are installed.\nif (!/\\bgraceful-fs\\b/.test(fs.closeSync.toString())) {\n  fs.closeSync = module.exports.closeSync;\n  fs.close = module.exports.close;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","module.exports = require(\"fs\");","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, cb) {\n      return orig.call(fs, target, function (er, stats) {\n        if (!stats) return cb.apply(this, arguments)\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target) {\n      var stats = orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","module.exports = require(\"constants\");","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","module.exports = require(\"stream\");","'use strict'\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","module.exports = require(\"assert\");","'use strict'\n\nmodule.exports = {\n  copySync: require('./copy-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirpSync = require('../mkdirs').mkdirsSync\nconst utimesSync = require('../util/utimes.js').utimesMillisSync\n\nconst notExist = Symbol('notExist')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const destStat = checkPaths(src, dest)\n\n  if (opts.filter && !opts.filter(src, dest)) return\n\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = require('../util/buffer')(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const destStat = checkPaths(srcItem, destItem)\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (destStat === notExist) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\n// return true if dest is a subdir of src, otherwise false.\nfunction isSrcSubdir (src, dest) {\n  const srcArray = path.resolve(src).split(path.sep)\n  const destArray = path.resolve(dest).split(path.sep)\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)\n}\n\nfunction checkStats (src, dest) {\n  const srcStat = fs.statSync(src)\n  let destStat\n  try {\n    destStat = fs.statSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return {srcStat, destStat: notExist}\n    throw err\n  }\n  return {srcStat, destStat}\n}\n\nfunction checkPaths (src, dest) {\n  const {srcStat, destStat} = checkStats(src, dest)\n  if (destStat.ino && destStat.ino === srcStat.ino) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)\n  }\n  return destStat\n}\n\nmodule.exports = copySync\n","module.exports = require(\"path\");","'use strict'\nconst u = require('universalify').fromCallback\nconst mkdirs = u(require('./mkdirs'))\nconst mkdirsSync = require('./mkdirs-sync')\n\nmodule.exports = {\n  mkdirs,\n  mkdirsSync,\n  // alias\n  mkdirp: mkdirs,\n  mkdirpSync: mkdirsSync,\n  ensureDir: mkdirs,\n  ensureDirSync: mkdirsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n","'use strict'\n\nconst path = require('path')\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    if (err0.code === 'ENOENT') {\n      if (path.dirname(p) === p) throw err0\n      made = mkdirsSync(path.dirname(p), opts, made)\n      mkdirsSync(p, opts, made)\n    } else {\n      // In the case of any other error, just see if there's a dir there\n      // already. If so, then hooray!  If not, then something is borked.\n      let stat\n      try {\n        stat = xfs.statSync(p)\n      } catch (err1) {\n        throw err0\n      }\n      if (!stat.isDirectory()) throw err0\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst path = require('path')\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis,\n  utimesMillisSync\n}\n","module.exports = require(\"os\");","'use strict'\n/* eslint-disable node/no-deprecated-api */\nmodule.exports = function (size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    try {\n      return Buffer.allocUnsafe(size)\n    } catch (e) {\n      return new Buffer(size)\n    }\n  }\n  return new Buffer(size)\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  copy: u(require('./copy'))\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirp = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimes = require('../util/utimes').utimesMillis\n\nconst notExist = Symbol('notExist')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  checkPaths(src, dest, (err, destStat) => {\n    if (err) return cb(err)\n    if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n    return checkParentDir(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) {\n      if (destStat) return onInclude(destStat, src, dest, opts, cb)\n      return onInclude(src, dest, opts, cb)\n    }\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  checkPaths(srcItem, destItem, (err, destStat) => {\n    if (err) return cb(err)\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (destStat === notExist) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\n// return true if dest is a subdir of src, otherwise false.\nfunction isSrcSubdir (src, dest) {\n  const srcArray = path.resolve(src).split(path.sep)\n  const destArray = path.resolve(dest).split(path.sep)\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)\n}\n\nfunction checkStats (src, dest, cb) {\n  fs.stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n    fs.stat(dest, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb(null, {srcStat, destStat: notExist})\n        return cb(err)\n      }\n      return cb(null, {srcStat, destStat})\n    })\n  })\n}\n\nfunction checkPaths (src, dest, cb) {\n  checkStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const {srcStat, destStat} = stats\n    if (destStat.ino && destStat.ino === srcStat.ino) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))\n    }\n    return cb(null, destStat)\n  })\n}\n\nmodule.exports = copy\n","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst rimraf = require('./rimraf')\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","'use strict'\n\nconst file = require('./file')\nconst link = require('./link')\nconst symlink = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    pathExists(dir, (err, dirExists) => {\n      if (err) return callback(err)\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch (e) {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = require('../path-exists').pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: u(jsonFile.readFile),\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: u(jsonFile.writeFile),\n  writeJsonSync: jsonFile.writeFileSync\n}\n","var _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  try {\n    var content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction stringify (obj, options) {\n  var spaces\n  var EOL = '\\n'\n  if (typeof options === 'object' && options !== null) {\n    if (options.spaces) {\n      spaces = options.spaces\n    }\n    if (options.EOL) {\n      EOL = options.EOL\n    }\n  }\n\n  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOL\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = ''\n  try {\n    str = stringify(obj, options)\n  } catch (err) {\n    // Need to return whether a callback was passed or not\n    if (callback) callback(err, null)\n    return\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n","'use strict'\n\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\nconst jsonFile = require('./jsonfile')\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst jsonFile = require('./jsonfile')\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy-sync').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirsSync\nconst buffer = require('../util/buffer')\n\nfunction moveSync (src, dest, options) {\n  options = options || {}\n  const overwrite = options.overwrite || options.clobber || false\n\n  src = path.resolve(src)\n  dest = path.resolve(dest)\n\n  if (src === dest) return fs.accessSync(src)\n\n  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`)\n\n  mkdirpSync(path.dirname(dest))\n  tryRenameSync()\n\n  function tryRenameSync () {\n    if (overwrite) {\n      try {\n        return fs.renameSync(src, dest)\n      } catch (err) {\n        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {\n          removeSync(dest)\n          options.overwrite = false // just overwriteed it, no need to do it again\n          return moveSync(src, dest, options)\n        }\n\n        if (err.code !== 'EXDEV') throw err\n        return moveSyncAcrossDevice(src, dest, overwrite)\n      }\n    } else {\n      try {\n        fs.linkSync(src, dest)\n        return fs.unlinkSync(src)\n      } catch (err) {\n        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {\n          return moveSyncAcrossDevice(src, dest, overwrite)\n        }\n        throw err\n      }\n    }\n  }\n}\n\nfunction moveSyncAcrossDevice (src, dest, overwrite) {\n  const stat = fs.statSync(src)\n\n  if (stat.isDirectory()) {\n    return moveDirSyncAcrossDevice(src, dest, overwrite)\n  } else {\n    return moveFileSyncAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveFileSyncAcrossDevice (src, dest, overwrite) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = buffer(BUF_LENGTH)\n\n  const flags = overwrite ? 'w' : 'wx'\n\n  const fdr = fs.openSync(src, 'r')\n  const stat = fs.fstatSync(fdr)\n  const fdw = fs.openSync(dest, flags, stat.mode)\n  let pos = 0\n\n  while (pos < stat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n  return fs.unlinkSync(src)\n}\n\nfunction moveDirSyncAcrossDevice (src, dest, overwrite) {\n  const options = {\n    overwrite: false\n  }\n\n  if (overwrite) {\n    removeSync(dest)\n    tryCopySync()\n  } else {\n    tryCopySync()\n  }\n\n  function tryCopySync () {\n    copySync(src, dest, options)\n    return removeSync(src)\n  }\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// extract dest base dir and check if that is the same as src basename\nfunction isSrcSubdir (src, dest) {\n  try {\n    return fs.statSync(src).isDirectory() &&\n           src !== dest &&\n           dest.indexOf(src) > -1 &&\n           dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src)\n  } catch (e) {\n    return false\n  }\n}\n\nmodule.exports = {\n  moveSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copy = require('../copy').copy\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirp\nconst pathExists = require('../path-exists').pathExists\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  src = path.resolve(src)\n  dest = path.resolve(dest)\n\n  if (src === dest) return fs.access(src, cb)\n\n  fs.stat(src, (err, st) => {\n    if (err) return cb(err)\n\n    if (st.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`))\n    }\n    mkdirp(path.dirname(dest), err => {\n      if (err) return cb(err)\n      return doRename(src, dest, overwrite, cb)\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nfunction isSrcSubdir (src, dest) {\n  const srcArray = src.split(path.sep)\n  const destArray = dest.split(path.sep)\n\n  return srcArray.reduce((acc, current, i) => {\n    return acc && destArray[i] === current\n  }, true)\n}\n\nmodule.exports = {\n  move: u(move)\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","\"use strict\";\n\nimport fs = require(\"fs-extra\");\nimport { window, workspace} from \"vscode\";\nexport let config = workspace.getConfiguration(\"r\");\n\nexport function getRpath() {\n    if (process.platform === \"win32\") {\n        return config.get(\"rterm.windows\") as string;\n    } else if (process.platform === \"darwin\") {\n        return config.get(\"rterm.mac\") as string;\n    } else if ( process.platform === \"linux\") {\n        return config.get(\"rterm.linux\") as string;\n    } else {\n        window.showErrorMessage(process.platform + \" can't use R\");\n        return \"\";\n    }\n}\n\nexport function ToRStringLiteral(s: string, quote: string) {\n    if (s === null) {\n        return \"NULL\";\n    }\n    return (quote +\n            s.replace(/\\\\/g, \"\\\\\\\\\")\n            .replace(/\"\"\"/g, \"\\\\\" + quote)\n            .replace(/\\\\n/g, \"\\\\n\")\n            .replace(/\\\\r/g, \"\\\\r\")\n            .replace(/\\\\t/g, \"\\\\t\")\n            .replace(/\\\\b/g, \"\\\\b\")\n            .replace(/\\\\a/g, \"\\\\a\")\n            .replace(/\\\\f/g, \"\\\\f\")\n            .replace(/\\\\v/g, \"\\\\v\") +\n            quote);\n}\n\nexport function delay(ms: number) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function checkForSpecialCharacters(text) {\n    return !/[~`!#$%\\^&*+=\\-\\[\\]\\\\';,/{}|\\\\\":<>\\?\\s]/g.test(text);\n}\n\nexport function checkIfFileExists(filePath) {\n    return fs.existsSync(filePath);\n}\n\nexport function assertRTerminalCreation(rTerm): boolean {\n    if (!rTerm) {\n        window.showErrorMessage(\"Could not create R terminal.\");\n        return false;\n    } else {\n        return true;\n    }\n}\n","\"use strict\";\n\nimport fs = require(\"fs-extra\");\nimport { commands, extensions, window, workspace } from \"vscode\";\nimport { createRTerm, rTerm } from \"./rTerminal\";\nimport { getSelection } from \"./selection\";\nimport { checkForSpecialCharacters, checkIfFileExists, delay } from \"./util\";\n\nexport async function previewEnvironment() {\n    if (!rTerm) {\n        const success = createRTerm(true);\n        if (!success) { return; }\n    }\n    if (!checkcsv()) {\n        return;\n    }\n    const tmpDir = makeTmpDir();\n    const pathToTmpCsv = tmpDir + \"/environment.csv\";\n    const envName = \"name=ls()\";\n    const envClass = \"class=sapply(ls(), function(x) {class(get(x))})\";\n    const envOut = \"out=sapply(ls(), function(x) {capture.output(str(get(x)), silent = T)[1]})\";\n    const rWriteCsvCommand = \"write.csv(data.frame(\"\n                             + envName + \",\"\n                             + envClass + \",\"\n                             + envOut + \"), '\"\n                             + pathToTmpCsv + \"', row.names=FALSE, quote = TRUE)\";\n    rTerm.sendText(rWriteCsvCommand);\n    await openTmpCSV(pathToTmpCsv, tmpDir);\n}\n\nexport async function previewDataframe() {\n    if (!rTerm) {\n        const success = createRTerm(true);\n        if (!success) { return; }\n    }\n    if (!checkcsv()) {\n        return;\n    }\n\n    const selectedTextArray = getSelection().selectedTextArray;\n    const dataframeName = selectedTextArray[0];\n\n    if (selectedTextArray.length !== 1 || !checkForSpecialCharacters(dataframeName)) {\n        window.showInformationMessage(\"This does not appear to be a dataframe.\");\n        return false;\n    }\n\n    const tmpDir = makeTmpDir();\n\n    // Create R write CSV command.  Turn off row names and quotes, they mess with Excel Viewer.\n    const pathToTmpCsv = tmpDir + \"/\" + dataframeName + \".csv\";\n    const rWriteCsvCommand = \"write.csv(\" + dataframeName + \", '\"\n                            + pathToTmpCsv\n                            + \"', row.names = FALSE, quote = FALSE)\";\n    rTerm.sendText(rWriteCsvCommand);\n    await openTmpCSV(pathToTmpCsv, tmpDir);\n}\n\nasync function openTmpCSV(pathToTmpCsv: string, tmpDir: string) {\n    await delay(350); // Needed since file size has not yet changed\n\n    if (!checkIfFileExists(pathToTmpCsv)) {\n        window.showErrorMessage(\"Dataframe failed to display.\");\n        fs.removeSync(tmpDir);\n        return false;\n    }\n\n    // Async poll for R to complete writing CSV.\n    const success = await waitForFileToFinish(pathToTmpCsv);\n    if (!success) {\n        window.showWarningMessage(\"Visual Studio Code currently limits opening files to 20 MB.\");\n        fs.removeSync(tmpDir);\n        return false;\n    }\n\n    if (process.platform === \"win32\") {\n        const winattr = require(\"winattr\");\n        winattr.setSync(tmpDir, {hidden: true});\n    }\n\n    // Open CSV in Excel Viewer and clean up.\n    workspace.openTextDocument(pathToTmpCsv).then(async (file) => {\n        await commands.executeCommand(\"csv.preview\", file.uri);\n        fs.removeSync(tmpDir);\n            });\n}\n\nasync function waitForFileToFinish(filePath) {\n    const fileBusy = true;\n    let currentSize = 0;\n    let previousSize = 1;\n\n    while (fileBusy) {\n        const stats = fs.statSync(filePath);\n        currentSize = stats.size;\n\n        // UPDATE: We are now limited to 20 mb by MODEL_TOKENIZATION_LIMIT\n        // https://github.com/Microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#L34\n        if (currentSize > 2 * 10000000) { // 20 MB\n            return false;\n        }\n\n        if (currentSize === previousSize) {\n            return true;\n        } else {\n            previousSize = currentSize;\n        }\n        await delay(50);\n    }\n}\n\nfunction makeTmpDir() {\n    let tmpDir = workspace.rootPath;\n    if (process.platform === \"win32\") {\n        tmpDir = tmpDir.replace(/\\\\/g, \"/\");\n        tmpDir += \"/tmp\";\n    } else {\n        tmpDir += \"/.tmp\";\n    }\n    if (!fs.existsSync(tmpDir)) {\n        fs.mkdirSync(tmpDir);\n    }\n    return tmpDir;\n}\n\nfunction checkcsv() {\n    const iscsv = extensions.getExtension(\"GrapeCity.gc-excelviewer\");\n    if (iscsv.isActive) {\n        return true;\n    } else {\n        window.showInformationMessage(\"This function need to install `GrapeCity.gc-excelviewer`\");\n        return false;\n    }\n}\n","\"use strict\";\n\nimport { Position, Range, window} from \"vscode\";\nimport { LineCache } from \"./lineCache\";\n\nexport function getSelection(): any {\n    const selection = { linesDownToMoveCursor: 0, selectedTextArray: [] };\n    const { start, end } = window.activeTextEditor.selection;\n    const currentDocument = window.activeTextEditor.document;\n    const range = new Range(start, end);\n\n    let selectedLine = currentDocument.getText(range);\n    if (!selectedLine) {\n        const { startLine, endLine }\n        = extendSelection(start.line, (x) => currentDocument.lineAt(x).text, currentDocument.lineCount);\n        const charactersOnLine = window.activeTextEditor.document.lineAt(endLine).text.length;\n        const newStart = new Position(startLine, 0);\n        const newEnd = new Position(endLine, charactersOnLine);\n        selection.linesDownToMoveCursor = 1 + endLine - start.line;\n        selectedLine = currentDocument.getText(new Range(newStart, newEnd));\n    } else if (start.line === end.line) {\n        selection.linesDownToMoveCursor = 0;\n        selection.selectedTextArray = [currentDocument.getText(new Range(start, end))];\n        return selection;\n    } else {\n        selectedLine = currentDocument.getText(new Range(start, end));\n    }\n\n    const selectedTextArray = selectedLine.split(\"\\n\");\n    selection.selectedTextArray = removeCommentedLines(selectedTextArray);\n\n    return selection;\n}\n\nfunction removeCommentedLines(selection: string[]): string[] {\n    const selectionWithoutComments = [];\n    selection.forEach((line) => {\n        if (!checkForComment(line)) { selectionWithoutComments.push(line); }\n    });\n    return selectionWithoutComments;\n}\n\nexport function checkForComment(line: string): boolean {\n    let index = 0;\n    while (index < line.length) {\n        if (!(line[index] === \" \")) { break; }\n        index++;\n    }\n    return line[index] === \"#\";\n}\n\n/**\n * Like vscode's Position class, but allows negative values.\n */\nclass PositionNeg {\n    public line: number;\n    public character;\n    public cter: number;\n    constructor(line: number, character: number) {\n        this.line = line;\n        this.character = character;\n    }\n}\n\nfunction doBracketsMatch(a: string, b: string): boolean {\n    const matches = { \"(\": \")\", \"[\": \"]\", \"{\": \"}\", \")\": \"(\", \"]\": \"[\", \"}\": \"{\" };\n    return matches[a] === b;\n}\n\nfunction isBracket(c: string, lookingForward: boolean) {\n    if (lookingForward) {\n        return ((c === \"(\") || (c === \"[\") || (c === \"{\"));\n    } else {\n        return ((c === \")\") || (c === \"]\") || (c === \"}\"));\n    }\n}\n\n/**\n * From a given position, return the 'next' character, its position in the document,\n * whether it is start/end of a code line (possibly broken over multiple text lines), and whether it is the\n * start/end of the file. Considers the start and end of each line to be special distinct characters.\n * @param p The starting position.\n * @param lookingForward true if the 'next' character is toward the end of the document, false if toward the start.\n * @param getLine A function that returns the string at the given line of the document.\n * @param getEndsInOperator A function that returns whether the given line ends in an operator.\n * @param lineCount The number of lines in the document.\n */\nfunction getNextChar(p: PositionNeg,\n                     lookingForward: boolean,\n                     getLine: (x: number) => string,\n                     getEndsInOperator: (y: number) => boolean,\n                     lineCount) {\n    const s = getLine(p.line);\n    let nextPos: PositionNeg = null;\n    let isEndOfCodeLine = false;\n    let isEndOfFile = false;\n    if (lookingForward) {\n        if (p.character !== s.length) {\n            nextPos = new PositionNeg(p.line, p.character + 1);\n        } else if (p.line < (lineCount - 1)) {\n            nextPos = new PositionNeg(p.line + 1, -1);\n        } else {\n            // At end of document. Return same character.\n            isEndOfFile = true;\n            nextPos = new PositionNeg(p.line, p.character);\n        }\n        const nextLine: string = getLine(nextPos.line);\n        if (nextPos.character === nextLine.length) {\n            if ((nextPos.line === (lineCount - 1)) || !getEndsInOperator(nextPos.line)) {\n                isEndOfCodeLine = true;\n            }\n        }\n    } else {\n        if (p.character !== -1) {\n            nextPos = new PositionNeg(p.line, p.character - 1);\n        } else if (p.line > 0) {\n            nextPos = new PositionNeg(p.line - 1, getLine(p.line - 1).length - 1);\n        } else {\n            // At start of document. Return same character.\n            isEndOfFile = true;\n            nextPos = new PositionNeg(p.line, p.character);\n        }\n        if (nextPos.character === -1) {\n            if ((nextPos.line <= 0) || !getEndsInOperator(nextPos.line - 1)) {\n                isEndOfCodeLine = true;\n            }\n        }\n    }\n    const nextChar = getLine(nextPos.line)[nextPos.character];\n    return ({ nextChar, nextPos, isEndOfCodeLine, isEndOfFile });\n}\n\n/**\n * Given a line number, gets the text of that line and determines the first and last lines of the\n * file required to make a complete line of code, by matching brackets and extending over\n * broken lines (single lines of code split into multiple text lines, joined by operators).\n *\n * The algorithm:\n * From the start of the given line, proceed forward looking for the end of the code line.\n * If a bracket is encountered, look for the match of that bracket (possibly changing direction to do so),\n * from the farthest point reached in that direction.\n * Once the bracket is found, proceed in the same direction looking for the completion of the code line.\n * Once the end of the code line has been matched, proceed in the other direction.\n * Repeat until all encountered brackets are matched, and the completions of the code lines have been reached in\n * both directions. The lines of the completions are the lines returned.\n *\n * Example:\n * Let's say we have the following R code file:\n *\n *     library(magrittr) # For %>%    Line 1\n *     list(x = 1,       #            Line 2\n *          y = 2) %>%   #            Line 3\n *         print()       #            Line 4\n *\n * Let's say the cursor is on Line 3. We proceed forward until we hit the ')'. We look for the match, which\n * means looking backwards from the end of Line 2. We find the match, '(', on Line 2. We continue along\n * Line 2 until we reach the start of the line. The previous line, Line 1, does not end in an operator,\n * so we have reached the completion of the code line. Now, we proceed forward again from the farthest point reached\n * in the other direction: the ')' on Line 3. We encounter the end of the TEXT line, but it ends in an operator '%>%',\n * so it is not the end of the CODE line. Therefore, we continue onto Line 4. We encounter a '(' on Line 4, and continue\n * forward to find its match, which is the next character. Then we're at the end of Line 4, which doesn't\n * end in an operator. Now we've found the completions in both directions, so we're finished. The farthest lines\n * reached were Line 2 and Line 4, so those are the values returned.\n * @param line The line of the document at which to start.\n * @param getLine A function that returns the string at the given line of the document.\n * @param lineCount The number of lines in the document.\n */\nexport function extendSelection(line: number, getLine: (line: number) => string, lineCount: number) {\n    const lc = new LineCache(getLine, lineCount);\n    const getLineFromCache = (x) => lc.getLineFromCache(x);\n    const getEndsInOperatorFromCache = (x) => lc.getEndsInOperatorFromCache(x);\n    let lookingForward = true;\n    // poss[1] is the farthest point reached looking forward from line,\n    // and poss[0] is the farthest point reached looking backward from line.\n    const poss = { 0: new PositionNeg(line, 0), 1: new PositionNeg(line, -1) };\n    const flagsFinish = { 0: false, 1: false }; // 1 represents looking forward, 0 represents looking back.\n    let flagAbort = false;\n    const unmatched = { 0: [] as string[], 1: [] as string[]};\n    while (!flagAbort && !(flagsFinish[0] && flagsFinish[1])) {\n        const { nextChar, nextPos, isEndOfCodeLine, isEndOfFile }\n        = getNextChar(poss[lookingForward ? 1 : 0],\n                      lookingForward,\n                      getLineFromCache,\n                      getEndsInOperatorFromCache,\n                      lineCount);\n        poss[lookingForward ? 1 : 0] = nextPos;\n        if (isBracket(nextChar, lookingForward)) {\n            unmatched[lookingForward ? 1 : 0].push(nextChar);\n        } else if (isBracket(nextChar, !lookingForward)) {\n            if (unmatched[lookingForward ? 1 : 0].length === 0) {\n                lookingForward = !lookingForward;\n                unmatched[lookingForward ? 1 : 0].push(nextChar);\n                flagsFinish[lookingForward ? 1 : 0] = false;\n            } else {\n                const needsToMatch = unmatched[lookingForward ? 1 : 0].pop();\n                if (!doBracketsMatch(nextChar, needsToMatch)) {\n                    flagAbort = true;\n                }\n            }\n        } else if (isEndOfCodeLine) {\n            if (unmatched[lookingForward ? 1 : 0].length === 0) {\n                // We have found everything we need to in this direction. Continue looking in the other direction.\n                flagsFinish[lookingForward ? 1 : 0] = true;\n                lookingForward = !lookingForward;\n            } else if (isEndOfFile) {\n                // Have hit the start or end of the file without finding the matching bracket.\n                flagAbort = true;\n            }\n        }\n    }\n    if (flagAbort) {\n        return ({ startLine: line, endLine: line });\n    } else {\n        return ({ startLine: poss[0].line, endLine: poss[1].line });\n    }\n}\n","\"use strict\";\n\n/**\n * Class to hold lines that have been fetched from the document after they have been preprocessed.\n */\nexport class LineCache {\n    public lineCache: Map<number, string>;\n    public endsInOperatorCache: Map<number, boolean>;\n    public getLine: (line: number) => string;\n    public lineCount: number;\n    constructor(getLine: (line: number) => string, lineCount: number) {\n        this.getLine = getLine;\n        this.lineCount = lineCount;\n        this.lineCache = new Map<number, string>();\n        this.endsInOperatorCache = new Map<number, boolean>();\n    }\n    public getLineFromCache(line: number) {\n        const lineInCache = this.lineCache.has(line);\n        if (!lineInCache) {\n            this.addLineToCache(line);\n        }\n        const s = this.lineCache.get(line);\n        return (s);\n    }\n    public getEndsInOperatorFromCache(line: number) {\n        const lineInCache = this.lineCache.has(line);\n        if (!lineInCache) {\n            this.addLineToCache(line);\n        }\n        const s = this.endsInOperatorCache.get(line);\n        return (s);\n    }\n    public addLineToCache(line: number) {\n        const cleaned = cleanLine(this.getLine(line));\n        const endsInOperator = doesLineEndInOperator(cleaned);\n        this.lineCache.set(line, cleaned);\n        this.endsInOperatorCache.set(line, endsInOperator);\n    }\n}\n\nfunction cleanLine(text: string) {\n    const cleaned = text.replace(/\\s*\\#.*/, \"\"); // Remove comments and preceeding spaces\n    return (cleaned);\n}\n\nfunction doesLineEndInOperator(text: string) {\n    const endingOperatorIndex = text.search(/(,|\\+|!|\\$|\\^|&|\\*|-|=|:|\\'|~|\\||\\/|\\?|%.*%)(\\s*|\\s*\\#.*)$/);\n    const spacesOnlyIndex = text.search(/^\\s*$/); // Space-only lines also counted.\n    return ((0 <= endingOperatorIndex) || (0 <= spacesOnlyIndex));\n}\n","\"use strict\";\nconst checkWindows = require(\"./checkWindows\");\nconst resolvePath = require(\"path\").resolve;\nconst whichLib = require(\"./whichLib\");\n\n\n\nfunction get(path, callback)\n{\n\tif (checkWindows.async(callback) === true)\n\t{\n\t\treturn whichLib.run( function()\n\t\t{\n\t\t\treturn whichLib.current().get( resolvePath(path), callback );\n\t\t});\n\t}\n}\n\n\n\nfunction getSync(path)\n{\n\tif (checkWindows.sync() === true)\n\t{\n\t\treturn whichLib.run( function()\n\t\t{\n\t\t\treturn whichLib.current().getSync( resolvePath(path) );\n\t\t});\n\t}\n}\n\n\n\nfunction set(path, attrs, callback)\n{\n\tif (checkWindows.async(callback) === true)\n\t{\n\t\treturn whichLib.run( function()\n\t\t{\n\t\t\treturn whichLib.current().set( resolvePath(path), attrs, callback );\n\t\t});\n\t}\n}\n\n\n\nfunction setSync(path, attrs)\n{\n\tif (checkWindows.sync() === true)\n\t{\n\t\treturn whichLib.run( function()\n\t\t{\n\t\t\treturn whichLib.current().setSync( resolvePath(path), attrs );\n\t\t});\n\t}\n}\n\n\n\nwhichLib.change(\"auto\");\n\n\n\nmodule.exports =\n{\n\tget:     get,\n\tgetSync: getSync,\n\tset:     set,\n\tsetSync: setSync,\n\t\n\t// Undocumented -- used for testing\n\tchange: whichLib.change\n};\n","\"use strict\";\nconst errorMessage = \"Not a Windows platform\";\nconst isWindows = process.platform.indexOf(\"win\") === 0;\n\n\n\nfunction async(callback)\n{\n\tif (isWindows === false)\n\t{\n\t\tif (typeof callback === \"function\")\n\t\t{\n\t\t\tcallback( new Error(errorMessage) );\n\t\t}\n\t}\n\t\n\treturn isWindows;\n}\n\n\n\nfunction sync()\n{\n\tif (isWindows === false)\n\t{\n\t\tthrow new Error(errorMessage);\n\t}\n\t\n\treturn isWindows;\n}\n\n\n\nmodule.exports = \n{\n\tasync: async,\n\tsync:  sync\n};\n","\"use strict\";\nconst checkWindows = require(\"./checkWindows\");\n\nconst lib = {\n\tmode: null,\n\tbinding: null,\n\tshell: null\n};\n\n\n\nfunction change(mode, strict)\n{\n\tif (checkWindows.async()===false) return;\n\t\n\tswitch (mode)\n\t{\n\t\tcase \"auto\":\n\t\tcase \"binding\":\n\t\t{\n\t\t\tif (lib.binding === null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tlib.binding = require(\"./binding\");\n\t\t\t\t\tlib.mode = \"binding\";\n\t\t\t\t}\n\t\t\t\tcatch (error)\n\t\t\t\t{\n\t\t\t\t\tif (strict !== true)\n\t\t\t\t\t{\n\t\t\t\t\t\tlib.binding = null;\n\t\t\t\t\t\tchange(\"shell\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// For tests to know which installations could not load the binding\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlib.mode = \"binding\";\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tcase \"shell\":\n\t\t{\n\t\t\tif (lib.shell===null) lib.shell = require(\"./shell\");\n\t\t\t\n\t\t\tlib.mode = \"shell\";\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n\nfunction current()\n{\n\treturn lib[lib.mode];\n}\n\n\n\nfunction run(callback)\n{\n\tvar result;\n\t\n\ttry\n\t{\n\t\tresult = callback();\n\t}\n\tcatch (error)\n\t{\n\t\t// If binding error\n\t\tif (lib.mode===\"binding\" && error.message===\"The specified procedure could not be found.\")\n\t\t{\n\t\t\tchange(\"shell\");\n\t\t\tresult = callback();\n\t\t}\n\t\t// If other error\n\t\telse\n\t\t{\n\t\t\tthrow error;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\n\n\nmodule.exports = \n{\n\tchange: change,\n\tcurrent: current,\n\trun: run\n};\n","\"use strict\";\nconst fswin = require(\"fswin\");\n\nconst convertAttrs = require(\"./convertAttrs\");\n\n\n\nfunction get(path, callback)\n{\n\tfswin.getAttributes(path, function(result)\n\t{\n\t\tif (result === undefined)\n\t\t{\n\t\t\t// fswin does not return an error -- problem could be ENOENT,EPERM,etc\n\t\t\tcallback( new Error(\"unknown error\") );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlet attrs = {};\n\t\t\n\t\tfor (let i in result)\n\t\t{\n\t\t\tif (i.indexOf(\"IS_\") === 0)\n\t\t\t{\n\t\t\t\tattrs[i] = result[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcallback( null, convertAttrs.from(attrs) );\n\t});\n}\n\n\n\nfunction getSync(path)\n{\n\tconst result = fswin.getAttributesSync(path);\n\t\n\tif (result === undefined)\n\t{\n\t\t// fswin does not return an error -- problem could be ENOENT,EPERM,etc\n\t\tthrow new Error(\"unknown erorr\");\n\t}\n\t\n\treturn convertAttrs.from(result);\n}\n\n\n\nfunction set(path, attrs, callback)\n{\n\tfswin.setAttributes(path, convertAttrs.to(attrs), function(success)\n\t{\n\t\t// fswin does not return an error -- problem could be ENOENT,EPERM,etc\n\t\tcallback( success===true ? null : new Error(\"unknown error\") );\n\t});\n}\n\n\n\nfunction setSync(path, attrs)\n{\n\tconst success = fswin.setAttributesSync( path, convertAttrs.to(attrs) );\n\t\n\tif (success === false)\n\t{\n\t\t// fswin does not return an error -- problem could be ENOENT,EPERM,etc\n\t\tthrow new Error(\"unknown erorr\");\n\t}\n}\n\n\n\nmodule.exports =\n{\n\tget:     get,\n\tgetSync: getSync,\n\tset:     set,\n\tsetSync: setSync\n};\n","'use strict';\r\nvar v, isElectron = process.versions && process.versions.electron;\r\nif (process.platform === 'win32') {\r\n    v = (isElectron ? process.versions.electron : process.version).match(/(\\d+\\.)(\\d+)\\./);\r\n    if (isElectron || v[1] === '0.') {\r\n\t\tv[2] = parseInt(v[2]);\r\n\t\tif (!isElectron && v[2] % 2) {\r\n\t\t\tv[2]++;\r\n\t\t}\r\n\t} else {\r\n\t\tv[2] = 'x';\r\n\t}\r\n\tmodule.exports = require((isElectron ? './electron/' : './node/') + v[1] + v[2] + '.x' + '/' + process.arch + '/fswin.node');\r\n} else {\r\n\tthrow 'this module only works on windows';\r\n}","var map = {\n\t\"./electron/1.3.x/ia32/fswin.node\": 56,\n\t\"./electron/1.3.x/x64/fswin.node\": 57,\n\t\"./electron/1.4.x/ia32/fswin.node\": 58,\n\t\"./electron/1.4.x/x64/fswin.node\": 59,\n\t\"./electron/1.6.x/ia32/fswin.node\": 60,\n\t\"./electron/1.6.x/x64/fswin.node\": 61,\n\t\"./node/0.10.x/ia32/fswin.node\": 62,\n\t\"./node/0.10.x/x64/fswin.node\": 63,\n\t\"./node/0.12.x/ia32/fswin.node\": 64,\n\t\"./node/0.12.x/x64/fswin.node\": 65,\n\t\"./node/0.6.x/ia32/fswin.node\": 66,\n\t\"./node/0.6.x/x64/fswin.node\": 67,\n\t\"./node/0.8.x/ia32/fswin.node\": 68,\n\t\"./node/0.8.x/x64/fswin.node\": 69,\n\t\"./node/4.x.x/ia32/fswin.node\": 70,\n\t\"./node/4.x.x/x64/fswin.node\": 71,\n\t\"./node/5.x.x/ia32/fswin.node\": 72,\n\t\"./node/5.x.x/x64/fswin.node\": 73,\n\t\"./node/6.x.x/ia32/fswin.node\": 74,\n\t\"./node/6.x.x/x64/fswin.node\": 75,\n\t\"./node/7.x.x/ia32/fswin.node\": 76,\n\t\"./node/7.x.x/x64/fswin.node\": 77,\n\t\"./node/8.x.x/ia32/fswin.node\": 78,\n\t\"./node/8.x.x/x64/fswin.node\": 79\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 55;","\"use strict\";\nconst defs =\n{\n\tarchive:  \"IS_ARCHIVED\",\n\thidden:   \"IS_HIDDEN\",\n\treadonly: \"IS_READ_ONLY\",\n\tsystem:   \"IS_SYSTEM\"\n};\n\n\n\nfunction convert(attrs, from)\n{\n\tconst output = {};\n\t\n\teachAttribute(attrs, function(attrValue, attrName)\n\t{\n\t\teachDefinition( function(defValue, defName)\n\t\t{\n\t\t\tif (from === true)\n\t\t\t{\n\t\t\t\tif (defValue === attrName)\n\t\t\t\t{\n\t\t\t\t\toutput[defName] = attrValue;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// to\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (defName === attrName)\n\t\t\t\t{\n\t\t\t\t\toutput[defValue] = attrValue;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\t\n\treturn output;\n}\n\n\n\nfunction convertFrom(attrs)\n{\n\treturn convert(attrs, true);\n}\n\n\n\nfunction convertTo(attrs)\n{\n\treturn convert(attrs, false);\n}\n\n\n\nfunction eachAttribute(attrs, callback)\n{\n\tfor (let i in attrs)\n\t{\n\t\tif (attrs.hasOwnProperty(i) === true)\n\t\t{\n\t\t\tlet stop = callback( attrs[i], i, attrs );\n\t\t\t\n\t\t\tif (stop===false) break;\n\t\t}\n\t}\n}\n\n\n\nfunction eachDefinition(callback)\n{\n\tfor (let i in defs)\n\t{\n\t\tif (defs.hasOwnProperty(i) === true)\n\t\t{\n\t\t\tlet stop = callback( defs[i], i, defs );\n\t\t\t\n\t\t\tif (stop===false) break;\n\t\t}\n\t}\n}\n\n\n\nmodule.exports =\n{\n\tfrom: convertFrom,\n\tto:   convertTo\n};\n","\"use strict\";\nconst child_process = require(\"child_process\");\n\n// For attrib command\nconst params =\n{\n\tarchive:  \"a\",\n\thidden:   \"h\",\n\treadonly: \"r\",\n\tsystem:   \"s\"\n};\n\n\n\nfunction get_args(path)\n{\n\treturn [\n\t\t__dirname+\"/hostscript.js\",\n\t\tpath,\n\t\t\"//nologo\",\n\t\t\"//E:jscript\"\n\t];\n}\n\n\n\nfunction get_parseResult(result)\n{\n\tvar json;\n\tvar error = null;\n\t\n\tresult.stdout = result.stdout.trim();\n\t\n\tif (result.stdout.length <= 0)\n\t{\n\t\terror = new Error(\"unknown error\");\n\t}\n\telse\n\t{\n\t\tjson = JSON.parse(result.stdout);\n\t\t\n\t\tif (json.error !== undefined)\n\t\t{\n\t\t\terror = new Error(json.error);\n\t\t\tjson = undefined;\n\t\t}\n\t}\n\t\n\treturn { error:error, attrs:json };\n}\n\n\n\nfunction set_args(path, attrs)\n{\n\tconst args = [];\n\t\n\tfor (let i in attrs)\n\t{\n\t\tif (attrs.hasOwnProperty(i)===true && params.hasOwnProperty(i)===true)\n\t\t{\n\t\t\targs.push( (attrs[i]===true ? \"+\" : \"-\") + params[i] );\n\t\t}\n\t}\n\t\n\targs.push(path);\n\t\n\treturn args;\n}\n\n\n\nfunction set_parseResult(result)\n{\n\t// `result.stdout` is empty when successful\n\tif (result.stdout.length <= 0)\n\t{\n\t\treturn null;\n\t}\n\telse\n\t{\n\t\treturn new Error(result.stdout);\n\t}\n}\n\n\n\nfunction shell(command, args, callback)\n{\n\tvar instance = child_process.spawn(command, args);\n\t\n\tvar stderr = \"\";\n\tvar stdout = \"\";\n\t\n\tinstance.stderr.on(\"data\", function(data)\n\t{\n\t\tstderr += data.toString();\n\t});\n\t\n\tinstance.stdout.on(\"data\", function(data)\n\t{\n\t\tstdout += data.toString();\n\t});\n\t\n\tinstance.on(\"exit\", function(status)\n\t{\n\t\tthis.removeAllListeners();\n\t\t\n\t\t// Pass an Object so that it's similar to spawnSync()\n\t\tcallback({ status:status, stdout:stdout, stderr:stderr });\n\t});\n}\n\n\n\nfunction shellSync(command, args)\n{\n\tvar result = child_process.spawnSync(command, args, {encoding:\"utf8\"});\n\t\n\t// Consistent with shell()\n\tif (result.stderr===null) result.stderr = \"\";\n\tif (result.stdout===null) result.stdout = \"\";\n\t\n\treturn result;\n}\n\n\n\n//::: PUBLIC FUNCTIONS\n\n\n\nfunction get(path, callback)\r\n{\n\tshell(\"cscript\", get_args(path), function(result)\n\t{\n\t\tresult = get_parseResult(result);\n\t\t\n\t\tcallback(result.error, result.attrs);\n\t});\r\n}\n\n\n\nfunction getSync(path)\n{\n\tvar result = shellSync( \"cscript\", get_args(path) );\n\tresult = get_parseResult(result);\n\t\n\tif (result.error !== null)\n\t{\n\t\tthrow result.error;\n\t}\n\t\n\treturn result.attrs;\n}\n\n\n\nfunction set(path, attrs, callback)\n{\n\tshell(\"attrib\", set_args(path,attrs), function(result)\n\t{\n\t\tcallback( set_parseResult(result) );\n\t});\n}\n\n\n\nfunction setSync(path, attrs, callback)\n{\n\tvar result = shellSync( \"attrib\", set_args(path,attrs) );\n\tresult = set_parseResult(result);\n\t\n\tif (result !== null)\n\t{\n\t\tthrow result;\n\t}\n}\n\n\n\nmodule.exports = \n{\n\tget:     get,\n\tgetSync: getSync,\n\tset:     set,\n\tsetSync: setSync\n};\n","module.exports = require(\"child_process\");","\"use strict\";\n\nimport fs = require(\"fs-extra\");\nimport path = require(\"path\");\nimport {  window, workspace } from \"vscode\";\nconst ignorePath =  path.join(workspace.rootPath, \".gitignore\");\n// From \"https://github.com/github/gitignore/raw/master/R.gitignore\"\nconst ignoreFiles = [\".Rhistory\",\n                    \".Rapp.history\",\n                    \".RData\",\n                    \"*-Ex.R\",\n                    \"/*.tar.gz\",\n                    \"/*.Rcheck/\",\n                    \".Rproj.user/\",\n                    \"vignettes/*.html\",\n                    \"vignettes/*.pdf\",\n                    \".httr-oauth\",\n                    \"/*_cache/\",\n                    \"/cache/\",\n                    \"*.utf8.md\",\n                    \"*.knit.md\",\n                    \"rsconnect/\"].join(\"\\n\");\n\nexport function createGitignore() {\n    if (!workspace.rootPath) {\n        window.showWarningMessage(\"Please open workspace to create .gitignore\");\n        return;\n    }\n    fs.writeFile(ignorePath, ignoreFiles, (err) => {\n        try {\n            if (err) {\n                window.showErrorMessage(err.name);\n            }\n        } catch (e) {\n            window.showErrorMessage(e.message);\n        }\n    });\n}\n"],"sourceRoot":""}